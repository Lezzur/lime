"""
Conflict detection and resolution for the sync engine.

Strategies:
  - Different fields on same entity → auto-merge (structural merge)
  - Same field conflict → domain-aware rules:
      * User corrections always beat AI-generated content
      * Deletions always win (tombstone propagation)
      * Default: latest HLC wins
  - DELETE vs UPDATE → delete wins
  - Knowledge graph: union-merge nodes/edges
  - Memory files: per-tier merge logic
"""

import json
import logging
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional

from backend.sync.clock import HLCTimestamp

logger = logging.getLogger(__name__)

# Fields that represent user corrections (always win over AI-generated)
USER_CORRECTION_FIELDS = {
    "transcript_segments": {"text"},
    "speakers": {"name"},
    "meeting_analyses": {"executive_summary"},
    "action_items": {"description", "owner", "deadline", "priority"},
    "analysis_decisions": {"description", "context"},
    "topic_segments": {"title", "summary"},
    "people": {"name", "role", "organization", "notes"},
    "projects": {"name", "description", "status"},
}

# Fields generated by AI (lose to user corrections)
AI_GENERATED_FIELDS = {
    "meeting_analyses": {"executive_summary", "meeting_type", "sentiment", "connections_data", "insights_data"},
    "action_items": {"confidence", "source_quote"},
    "analysis_decisions": {"confidence", "source_quote"},
    "topic_segments": {"confidence"},
}


class ResolutionStrategy(str, Enum):
    LOCAL_WINS = "local_wins"
    REMOTE_WINS = "remote_wins"
    MERGE = "merge"
    DELETE_WINS = "delete_wins"


@dataclass
class ConflictResult:
    strategy: ResolutionStrategy
    merged_fields: Optional[dict] = None
    details: str = ""


@dataclass
class ChangeEntry:
    """Lightweight representation of a changelog entry for conflict detection."""
    hlc_timestamp: str
    device_id: str
    entity_table: str
    entity_id: str
    operation: str  # INSERT, UPDATE, DELETE
    changed_fields: Optional[dict] = field(default=None)


class ConflictResolver:
    """Domain-aware conflict detection and resolution."""

    def detect_and_resolve(
        self,
        local: ChangeEntry,
        remote: ChangeEntry,
    ) -> ConflictResult:
        """Detect conflict between a local and remote change to the same entity."""

        # DELETE always wins
        if remote.operation == "DELETE":
            return ConflictResult(
                strategy=ResolutionStrategy.DELETE_WINS,
                details="Remote delete wins",
            )
        if local.operation == "DELETE":
            return ConflictResult(
                strategy=ResolutionStrategy.DELETE_WINS,
                details="Local delete wins",
            )

        # INSERT vs INSERT (rare — same entity_id on both devices)
        if local.operation == "INSERT" and remote.operation == "INSERT":
            return self._resolve_insert_conflict(local, remote)

        # UPDATE vs UPDATE — the interesting case
        if local.operation == "UPDATE" and remote.operation == "UPDATE":
            return self._resolve_update_conflict(local, remote)

        # INSERT vs UPDATE or vice versa: remote wins (it has more recent state)
        local_ts = HLCTimestamp.from_string(local.hlc_timestamp)
        remote_ts = HLCTimestamp.from_string(remote.hlc_timestamp)
        if remote_ts > local_ts:
            return ConflictResult(
                strategy=ResolutionStrategy.REMOTE_WINS,
                details="Remote timestamp is newer",
            )
        return ConflictResult(
            strategy=ResolutionStrategy.LOCAL_WINS,
            details="Local timestamp is newer",
        )

    def _resolve_update_conflict(
        self,
        local: ChangeEntry,
        remote: ChangeEntry,
    ) -> ConflictResult:
        local_fields = local.changed_fields or {}
        remote_fields = remote.changed_fields or {}

        local_keys = set(local_fields.keys())
        remote_keys = set(remote_fields.keys())
        overlapping = local_keys & remote_keys

        # No overlapping fields → structural merge
        if not overlapping:
            merged = {**local_fields, **remote_fields}
            return ConflictResult(
                strategy=ResolutionStrategy.MERGE,
                merged_fields=merged,
                details=f"Structural merge: {len(local_keys)} local + {len(remote_keys)} remote fields",
            )

        # Overlapping fields — apply domain rules
        merged = dict(local_fields)  # start with local
        table = local.entity_table

        for f in overlapping:
            winner = self._resolve_field_conflict(table, f, local, remote)
            if winner == "remote":
                merged[f] = remote_fields[f]
            # else keep local value already in merged

        # Add non-overlapping remote fields
        for f in remote_keys - overlapping:
            merged[f] = remote_fields[f]

        return ConflictResult(
            strategy=ResolutionStrategy.MERGE,
            merged_fields=merged,
            details=f"Field-level merge with {len(overlapping)} conflicts resolved",
        )

    def _resolve_field_conflict(
        self,
        table: str,
        field_name: str,
        local: ChangeEntry,
        remote: ChangeEntry,
    ) -> str:
        """Returns 'local' or 'remote' for a conflicting field."""
        # User corrections always beat AI-generated content
        user_fields = USER_CORRECTION_FIELDS.get(table, set())
        ai_fields = AI_GENERATED_FIELDS.get(table, set())

        if field_name in user_fields and field_name in ai_fields:
            # Both are possible — check if the correction flag exists
            pass  # fall through to HLC

        if field_name in user_fields:
            # For user-correctable fields, latest wins (user likely corrected last)
            local_ts = HLCTimestamp.from_string(local.hlc_timestamp)
            remote_ts = HLCTimestamp.from_string(remote.hlc_timestamp)
            return "remote" if remote_ts > local_ts else "local"

        # Default: latest HLC wins
        local_ts = HLCTimestamp.from_string(local.hlc_timestamp)
        remote_ts = HLCTimestamp.from_string(remote.hlc_timestamp)
        return "remote" if remote_ts > local_ts else "local"

    def _resolve_insert_conflict(
        self,
        local: ChangeEntry,
        remote: ChangeEntry,
    ) -> ConflictResult:
        """Handle INSERT vs INSERT on the same entity_id (very rare)."""
        # Merge all fields, remote wins on overlap (arbitrary but deterministic)
        local_fields = local.changed_fields or {}
        remote_fields = remote.changed_fields or {}
        merged = {**local_fields, **remote_fields}
        return ConflictResult(
            strategy=ResolutionStrategy.MERGE,
            merged_fields=merged,
            details="INSERT-INSERT merge: remote fields take precedence on overlap",
        )


class KnowledgeGraphMerger:
    """Union-merge for knowledge_graph.json files."""

    @staticmethod
    def merge(local_data: dict, remote_data: dict) -> dict:
        """Merge two knowledge graph JSON structures. Union of nodes and edges."""
        local_nodes = {n["id"]: n for n in local_data.get("nodes", [])}
        remote_nodes = {n["id"]: n for n in remote_data.get("nodes", [])}

        # Union nodes — remote wins on conflict
        merged_nodes = {**local_nodes, **remote_nodes}

        # Union edges — deduplicate by (source, target, type)
        local_edges = local_data.get("edges", [])
        remote_edges = remote_data.get("edges", [])
        edge_key = lambda e: (e.get("source"), e.get("target"), e.get("type"))

        seen = set()
        merged_edges = []
        for e in remote_edges + local_edges:
            k = edge_key(e)
            if k not in seen:
                seen.add(k)
                merged_edges.append(e)

        return {
            "nodes": list(merged_nodes.values()),
            "edges": merged_edges,
        }


class MemoryFileMerger:
    """Per-tier merge logic for memory .md files."""

    @staticmethod
    def merge_short_term(local_lines: list[str], remote_lines: list[str]) -> list[str]:
        """Short-term memory: deduplicate entries."""
        seen = set()
        merged = []
        for line in remote_lines + local_lines:
            stripped = line.strip()
            if stripped and stripped not in seen:
                seen.add(stripped)
                merged.append(line)
        return merged

    @staticmethod
    def merge_medium_term(local_data: list[dict], remote_data: list[dict]) -> list[dict]:
        """Medium-term memory: merge patterns by ID."""
        local_by_id = {p["id"]: p for p in local_data if "id" in p}
        remote_by_id = {p["id"]: p for p in remote_data if "id" in p}

        # Remote wins on ID overlap
        merged = {**local_by_id, **remote_by_id}
        return list(merged.values())

    @staticmethod
    def merge_long_term(local_lines: list[str], remote_lines: list[str]) -> list[str]:
        """Long-term memory: union merge."""
        seen = set()
        merged = []
        for line in remote_lines + local_lines:
            stripped = line.strip()
            if stripped and stripped not in seen:
                seen.add(stripped)
                merged.append(line)
        return merged
